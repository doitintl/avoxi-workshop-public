import {
  __spreadProps,
  __spreadValues
} from "./chunk-7OAPEGJQ.mjs";
import { GENKIT_VERSION } from "@genkit-ai/core";
import { logger } from "@genkit-ai/core/logging";
import {
  internalMetricNamespaceWrap,
  MetricCounter,
  MetricHistogram
} from "@genkit-ai/core/metrics";
import {
  spanMetadataAls,
  toDisplayPath,
  traceMetadataAls
} from "@genkit-ai/core/tracing";
import { ValueType } from "@opentelemetry/api";
const _N = internalMetricNamespaceWrap.bind(null, "flow");
const flowCounter = new MetricCounter(_N("requests"), {
  description: "Counts calls to genkit flows.",
  valueType: ValueType.INT
});
const pathCounter = new MetricCounter(_N("path/requests"), {
  description: "Tracks unique flow paths per flow.",
  valueType: ValueType.INT
});
const pathLatencies = new MetricHistogram(_N("path/latency"), {
  description: "Latencies per flow path.",
  ValueType: ValueType.DOUBLE,
  unit: "ms"
});
const flowLatencies = new MetricHistogram(_N("latency"), {
  description: "Latencies when calling Genkit flows.",
  valueType: ValueType.DOUBLE,
  unit: "ms"
});
function recordError(err) {
  var _a, _b, _c, _d, _e;
  const paths = ((_b = (_a = traceMetadataAls) == null ? void 0 : _a.getStore()) == null ? void 0 : _b.paths) || /* @__PURE__ */ new Set();
  const failedPath = ((_c = Array.from(paths).find((p) => p.status === "failure")) == null ? void 0 : _c.path) || ((_e = (_d = spanMetadataAls) == null ? void 0 : _d.getStore()) == null ? void 0 : _e.path) || "";
  const displayPath = toDisplayPath(failedPath);
  logger.logStructuredError(`Error[${displayPath}, ${err.name}]`, {
    path: displayPath,
    qualifiedPath: failedPath,
    name: err.name,
    message: err.message,
    stack: err.stack,
    source: "ts",
    sourceVersion: GENKIT_VERSION
  });
}
function writeFlowSuccess(flowName, latencyMs) {
  const dimensions = {
    name: flowName,
    status: "success",
    source: "ts",
    sourceVersion: GENKIT_VERSION
  };
  flowCounter.add(1, dimensions);
  flowLatencies.record(latencyMs, dimensions);
  writePathMetrics(flowName, latencyMs);
}
function writeFlowFailure(flowName, latencyMs, err) {
  const dimensions = {
    name: flowName,
    status: "failure",
    source: "ts",
    sourceVersion: GENKIT_VERSION,
    error: err.name
  };
  flowCounter.add(1, dimensions);
  flowLatencies.record(latencyMs, dimensions);
  writePathMetrics(flowName, latencyMs, err);
}
function logRequest(flowName, req) {
  var _a, _b;
  const qualifiedPath = ((_b = (_a = spanMetadataAls) == null ? void 0 : _a.getStore()) == null ? void 0 : _b.path) || "";
  const path = toDisplayPath(qualifiedPath);
  logger.logStructured(`Request[${flowName}]`, {
    flowName,
    headers: __spreadProps(__spreadValues({}, req.headers), {
      authorization: "<redacted>"
    }),
    params: req.params,
    body: req.body,
    query: req.query,
    originalUrl: req.originalUrl,
    path,
    qualifiedPath,
    source: "ts",
    sourceVersion: GENKIT_VERSION
  });
}
function logResponse(flowName, respCode, respBody) {
  var _a, _b;
  const qualifiedPath = ((_b = (_a = spanMetadataAls) == null ? void 0 : _a.getStore()) == null ? void 0 : _b.path) || "";
  const path = toDisplayPath(qualifiedPath);
  logger.logStructured(`Response[${flowName}]`, {
    flowName,
    path,
    qualifiedPath,
    code: respCode,
    body: respBody,
    source: "ts",
    sourceVersion: GENKIT_VERSION
  });
}
function writePathMetrics(flowName, latencyMs, err) {
  var _a, _b, _c;
  const paths = ((_a = traceMetadataAls.getStore()) == null ? void 0 : _a.paths) || /* @__PURE__ */ new Set();
  const flowPaths = Array.from(paths).filter(
    (meta) => meta.path.includes(flowName)
  );
  if (flowPaths) {
    logger.logStructured(`Paths[${flowName}]`, {
      flowName,
      paths: flowPaths.map((p) => toDisplayPath(p.path))
    });
    flowPaths.forEach((p) => writePathMetric(flowName, p));
    if (err && !flowPaths.some((p) => p.status === "failure")) {
      writePathMetric(flowName, {
        status: "failure",
        path: ((_c = (_b = spanMetadataAls) == null ? void 0 : _b.getStore()) == null ? void 0 : _c.path) || "",
        error: err,
        latency: latencyMs
      });
    }
  }
}
function writePathMetric(flowName, meta) {
  const pathDimensions = {
    flowName,
    status: meta.status,
    error: meta.error,
    path: meta.path,
    source: "ts",
    sourceVersion: GENKIT_VERSION
  };
  pathCounter.add(1, pathDimensions);
  pathLatencies.record(meta.latency, pathDimensions);
}
export {
  logRequest,
  logResponse,
  recordError,
  writeFlowFailure,
  writeFlowSuccess
};
//# sourceMappingURL=telemetry.mjs.map