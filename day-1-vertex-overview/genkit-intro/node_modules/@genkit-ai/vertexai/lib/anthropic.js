"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => {
  return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
var anthropic_exports = {};
__export(anthropic_exports, {
  AnthropicConfigSchema: () => AnthropicConfigSchema,
  SUPPORTED_ANTHROPIC_MODELS: () => SUPPORTED_ANTHROPIC_MODELS,
  anthropicModel: () => anthropicModel,
  claude35Sonnet: () => claude35Sonnet,
  claude3Haiku: () => claude3Haiku,
  claude3Opus: () => claude3Opus,
  claude3Sonnet: () => claude3Sonnet,
  fromAnthropicResponse: () => fromAnthropicResponse,
  toAnthropicRequest: () => toAnthropicRequest
});
module.exports = __toCommonJS(anthropic_exports);
var import_vertex_sdk = require("@anthropic-ai/vertex-sdk");
var import_model = require("@genkit-ai/ai/model");
var import_core = require("@genkit-ai/core");
var import_zod = __toESM(require("zod"));
const AnthropicConfigSchema = import_model.GenerationCommonConfigSchema.extend({
  location: import_zod.default.string().optional()
});
const claude35Sonnet = (0, import_model.modelRef)({
  name: "vertexai/claude-3-5-sonnet",
  info: {
    label: "Vertex AI Model Garden - Claude 3.5 Sonnet",
    versions: ["claude-3-5-sonnet@20240620"],
    supports: {
      multiturn: true,
      media: true,
      tools: true,
      systemRole: true,
      output: ["text"]
    }
  },
  configSchema: AnthropicConfigSchema
});
const claude3Sonnet = (0, import_model.modelRef)({
  name: "vertexai/claude-3-sonnet",
  info: {
    label: "Vertex AI Model Garden - Claude 3 Sonnet",
    versions: ["claude-3-sonnet@20240229"],
    supports: {
      multiturn: true,
      media: true,
      tools: true,
      systemRole: true,
      output: ["text"]
    }
  },
  configSchema: AnthropicConfigSchema
});
const claude3Haiku = (0, import_model.modelRef)({
  name: "vertexai/claude-3-haiku",
  info: {
    label: "Vertex AI Model Garden - Claude 3 Haiku",
    versions: ["claude-3-haiku@20240307"],
    supports: {
      multiturn: true,
      media: true,
      tools: true,
      systemRole: true,
      output: ["text"]
    }
  },
  configSchema: AnthropicConfigSchema
});
const claude3Opus = (0, import_model.modelRef)({
  name: "vertexai/claude-3-opus",
  info: {
    label: "Vertex AI Model Garden - Claude 3 Opus",
    versions: ["claude-3-opus@20240229"],
    supports: {
      multiturn: true,
      media: true,
      tools: true,
      systemRole: true,
      output: ["text"]
    }
  },
  configSchema: AnthropicConfigSchema
});
const SUPPORTED_ANTHROPIC_MODELS = {
  "claude-3-5-sonnet": claude35Sonnet,
  "claude-3-sonnet": claude3Sonnet,
  "claude-3-opus": claude3Opus,
  "claude-3-haiku": claude3Haiku
};
function toAnthropicRequest(model, input) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  let system = void 0;
  const messages = [];
  for (const msg of input.messages) {
    if (msg.role === "system") {
      system = msg.content.map((c) => {
        if (!c.text) {
          throw new Error(
            "Only text context is supported for system messages."
          );
        }
        return c.text;
      }).join();
    } else if (msg.content[msg.content.length - 1].toolResponse) {
      messages.push({
        role: "user",
        content: toAnthropicContent(msg.content)
      });
    } else {
      messages.push({
        role: toAnthropicRole(msg.role),
        content: toAnthropicContent(msg.content)
      });
    }
  }
  const request = {
    model,
    messages,
    // https://docs.anthropic.com/claude/docs/models-overview#model-comparison
    max_tokens: (_b = (_a = input.config) == null ? void 0 : _a.maxOutputTokens) != null ? _b : 4096
  };
  if (system) {
    request["system"] = system;
  }
  if (input.tools) {
    request.tools = (_c = input.tools) == null ? void 0 : _c.map((tool) => {
      return {
        name: tool.name,
        description: tool.description,
        input_schema: tool.inputSchema
      };
    });
  }
  if ((_d = input.config) == null ? void 0 : _d.stopSequences) {
    request.stop_sequences = (_e = input.config) == null ? void 0 : _e.stopSequences;
  }
  if ((_f = input.config) == null ? void 0 : _f.temperature) {
    request.temperature = (_g = input.config) == null ? void 0 : _g.temperature;
  }
  if ((_h = input.config) == null ? void 0 : _h.topK) {
    request.top_k = (_i = input.config) == null ? void 0 : _i.topK;
  }
  if ((_j = input.config) == null ? void 0 : _j.topP) {
    request.top_p = (_k = input.config) == null ? void 0 : _k.topP;
  }
  return request;
}
function toAnthropicContent(content) {
  return content.map((p) => {
    if (p.text) {
      return {
        type: "text",
        text: p.text
      };
    }
    if (p.media) {
      let b64Data = p.media.url;
      if (b64Data.startsWith("data:")) {
        b64Data = b64Data.substring(b64Data.indexOf(",") + 1);
      }
      return {
        type: "image",
        source: {
          type: "base64",
          data: b64Data,
          media_type: p.media.contentType
        }
      };
    }
    if (p.toolRequest) {
      return toAnthropicToolRequest(p.toolRequest);
    }
    if (p.toolResponse) {
      return toAnthropicToolResponse(p);
    }
    throw new Error(`Unsupported content type: ${JSON.stringify(p)}`);
  });
}
function toAnthropicRole(role) {
  if (role === "model") {
    return "assistant";
  }
  if (role === "user") {
    return "user";
  }
  if (role === "tool") {
    return "assistant";
  }
  throw new Error(`Unsupported role type ${role}`);
}
function fromAnthropicTextPart(part) {
  return {
    text: part.text
  };
}
function fromAnthropicToolCallPart(part) {
  return {
    toolRequest: {
      name: part.name,
      input: part.input,
      ref: part.id
    }
  };
}
function fromAnthropicPart(part) {
  if (part.type === "text")
    return fromAnthropicTextPart(part);
  if (part.type === "tool_use")
    return fromAnthropicToolCallPart(part);
  throw new Error(
    "Part type is unsupported/corrupted. Either data is missing or type cannot be inferred from type."
  );
}
function fromAnthropicCandidate(candidate) {
  const parts = candidate.content;
  const genkitCandidate = {
    index: 0,
    message: {
      role: "model",
      content: parts.map(fromAnthropicPart)
    },
    finishReason: toGenkitFinishReason(
      candidate.stop_reason
    ),
    custom: {
      id: candidate.id,
      model: candidate.model,
      type: candidate.type
    }
  };
  return genkitCandidate;
}
function fromAnthropicResponse(input, response) {
  const candidates = [fromAnthropicCandidate(response)];
  return {
    candidates,
    usage: __spreadProps(__spreadValues({}, (0, import_model.getBasicUsageStats)(input.messages, candidates)), {
      inputTokens: response.usage.input_tokens,
      outputTokens: response.usage.output_tokens
    })
  };
}
function toGenkitFinishReason(reason) {
  switch (reason) {
    case "end_turn":
      return "stop";
    case "max_tokens":
      return "length";
    case "stop_sequence":
      return "stop";
    case "tool_use":
      return "stop";
    case null:
      return "unknown";
    default:
      return "other";
  }
}
function toAnthropicToolRequest(tool) {
  if (!tool.name) {
    throw new Error("Tool name is required");
  }
  if (!/^[a-zA-Z0-9_-]{1,64}$/.test(tool.name)) {
    throw new Error(
      `Tool name ${tool.name} contains invalid characters. 
      Only letters, numbers, and underscores are allowed, 
      and the name must be between 1 and 64 characters long.`
    );
  }
  const declaration = {
    type: "tool_use",
    id: tool.ref,
    name: tool.name,
    input: tool.input
  };
  return declaration;
}
function toAnthropicToolResponse(part) {
  var _a;
  if (!((_a = part.toolResponse) == null ? void 0 : _a.ref)) {
    throw new Error("Tool response reference is required");
  }
  if (!part.toolResponse.output) {
    throw new Error("Tool response output is required");
  }
  return {
    type: "tool_result",
    tool_use_id: part.toolResponse.ref,
    content: JSON.stringify(part.toolResponse.output)
  };
}
function anthropicModel(modelName, projectId, region) {
  var _a, _b, _c;
  const clients = {};
  const clientFactory = (region2) => {
    if (!clients[region2]) {
      clients[region2] = new import_vertex_sdk.AnthropicVertex({
        region: region2,
        projectId,
        defaultHeaders: {
          "X-Goog-Api-Client": import_core.GENKIT_CLIENT_HEADER
        }
      });
    }
    return clients[region2];
  };
  const model = SUPPORTED_ANTHROPIC_MODELS[modelName];
  if (!model) {
    throw new Error(`unsupported Anthropic model name ${modelName}`);
  }
  return (0, import_model.defineModel)(
    {
      name: model.name,
      label: (_a = model.info) == null ? void 0 : _a.label,
      configSchema: AnthropicConfigSchema,
      supports: (_b = model.info) == null ? void 0 : _b.supports,
      versions: (_c = model.info) == null ? void 0 : _c.versions
    },
    (input, streamingCallback) => __async(this, null, function* () {
      var _a2, _b2, _c2, _d, _e;
      const client = clientFactory(((_a2 = input.config) == null ? void 0 : _a2.location) || region);
      if (!streamingCallback) {
        const response = yield client.messages.create(__spreadProps(__spreadValues({}, toAnthropicRequest((_c2 = (_b2 = input.config) == null ? void 0 : _b2.version) != null ? _c2 : modelName, input)), {
          stream: false
        }));
        return fromAnthropicResponse(input, response);
      } else {
        const stream = yield client.messages.stream(
          toAnthropicRequest((_e = (_d = input.config) == null ? void 0 : _d.version) != null ? _e : modelName, input)
        );
        try {
          for (var iter = __forAwait(stream), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
            const event = temp.value;
            if (event.type === "content_block_delta") {
              streamingCallback({
                index: 0,
                content: [
                  {
                    text: event.delta.text
                  }
                ]
              });
            }
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield temp.call(iter));
          } finally {
            if (error)
              throw error[0];
          }
        }
        return fromAnthropicResponse(input, yield stream.finalMessage());
      }
    })
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AnthropicConfigSchema,
  SUPPORTED_ANTHROPIC_MODELS,
  anthropicModel,
  claude35Sonnet,
  claude3Haiku,
  claude3Opus,
  claude3Sonnet,
  fromAnthropicResponse,
  toAnthropicRequest
});
//# sourceMappingURL=anthropic.js.map