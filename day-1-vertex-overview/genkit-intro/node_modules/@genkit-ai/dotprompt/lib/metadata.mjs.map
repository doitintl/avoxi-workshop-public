{"version":3,"sources":["../src/metadata.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//\n// IMPORTANT: Please keep type definitions in sync with\n//   genkit-tools/src/types/prompt.ts\n//\n\nimport {\n  GenerationCommonConfigSchema,\n  ModelArgument,\n} from '@genkit-ai/ai/model';\nimport { ToolArgument } from '@genkit-ai/ai/tool';\nimport { lookupSchema } from '@genkit-ai/core/registry';\nimport { JSONSchema, parseSchema, toJsonSchema } from '@genkit-ai/core/schema';\nimport z from 'zod';\nimport { picoschema } from './picoschema.js';\n\n/**\n * Metadata for a prompt.\n */\nexport interface PromptMetadata<\n  Input extends z.ZodTypeAny = z.ZodTypeAny,\n  Options extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  /** The name of the prompt. */\n  name?: string;\n\n  /** The variant name for the prompt. */\n  variant?: string;\n\n  /** The name of the model to use for this prompt, e.g. `vertexai/gemini-1.0-pro` */\n  model?: ModelArgument<Options>;\n\n  /** Names of tools (registered separately) to allow use of in this prompt. */\n  tools?: ToolArgument[];\n\n  /** Number of candidates to generate by default. */\n  candidates?: number;\n\n  /** Model configuration. Not all models support all options. */\n  config?: z.infer<Options>;\n\n  input?: {\n    /** Defines the default input variable values to use if none are provided. */\n    default?: any;\n    /** Zod schema defining the input variables. */\n    schema?: Input;\n    /**\n     * Defines the input variables that can be passed into the template in JSON schema form.\n     * If not supplied, any object will be accepted. `{type: \"object\"}` is defaulted if not\n     * supplied.\n     */\n    jsonSchema?: JSONSchema;\n  };\n\n  /** Defines the expected model output format. */\n  output?: {\n    /** Desired output format for this prompt. */\n    format?: 'json' | 'text' | 'media';\n    /** Zod schema defining the output structure (cannot be specified with non-json format). */\n    schema?: z.ZodTypeAny;\n    /** JSON schema of desired output (cannot be specified with non-json format). */\n    jsonSchema?: JSONSchema;\n  };\n\n  /** Arbitrary metadata to be used by code, tools, and libraries. */\n  metadata?: Record<string, any>;\n}\n\n/**\n * Formal schema for prompt YAML frontmatter.\n */\nexport const PromptFrontmatterSchema = z.object({\n  name: z.string().optional(),\n  variant: z.string().optional(),\n  model: z.string().optional(),\n  tools: z.array(z.string()).optional(),\n  candidates: z.number().optional(),\n  config: GenerationCommonConfigSchema.passthrough().optional(),\n  input: z\n    .object({\n      default: z.any(),\n      schema: z.unknown(),\n    })\n    .optional(),\n  output: z\n    .object({\n      format: z.enum(['json', 'text', 'media']).optional(),\n      schema: z.unknown().optional(),\n    })\n    .optional(),\n  metadata: z.record(z.unknown()).optional(),\n});\n\nexport type PromptFrontmatter = z.infer<typeof PromptFrontmatterSchema>;\n\nfunction stripUndefinedOrNull(obj: any) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  for (const key in obj) {\n    if (obj[key] === undefined || obj[key] === null) {\n      delete obj[key];\n    } else if (typeof obj[key] === 'object') {\n      stripUndefinedOrNull(obj[key]); // Recurse into nested objects\n    }\n  }\n  return obj;\n}\n\nfunction fmSchemaToSchema(fmSchema: any) {\n  if (!fmSchema) return {};\n  if (typeof fmSchema === 'string') return lookupSchema(fmSchema);\n  return { jsonSchema: picoschema(fmSchema) };\n}\n\nexport function toMetadata(attributes: unknown): Partial<PromptMetadata> {\n  const fm = parseSchema<z.infer<typeof PromptFrontmatterSchema>>(attributes, {\n    schema: PromptFrontmatterSchema,\n  });\n\n  let input: PromptMetadata['input'] | undefined;\n  if (fm.input) {\n    input = { default: fm.input.default, ...fmSchemaToSchema(fm.input.schema) };\n  }\n\n  let output: PromptMetadata['output'] | undefined;\n  if (fm.output) {\n    output = {\n      format: fm.output.format,\n      ...fmSchemaToSchema(fm.output.schema),\n    };\n  }\n\n  return stripUndefinedOrNull({\n    name: fm.name,\n    variant: fm.variant,\n    model: fm.model,\n    config: fm.config,\n    input,\n    output,\n    metadata: fm.metadata,\n    tools: fm.tools,\n    candidates: fm.candidates,\n  });\n}\n\nexport function toFrontmatter(md: PromptMetadata): PromptFrontmatter {\n  return stripUndefinedOrNull({\n    name: md.name,\n    variant: md.variant,\n    model: typeof md.model === 'string' ? md.model : md.model?.name,\n    config: md.config,\n    input: md.input\n      ? {\n          default: md.input.default,\n          schema: toJsonSchema({\n            schema: md.input.schema,\n            jsonSchema: md.input.jsonSchema,\n          }),\n        }\n      : undefined,\n    output: md.output\n      ? {\n          format: md.output.format,\n          schema: toJsonSchema({\n            schema: md.output.schema,\n            jsonSchema: md.output.jsonSchema,\n          }),\n        }\n      : undefined,\n    metadata: md.metadata,\n    tools: md.tools?.map((t) =>\n      typeof t === 'string' ? t : (t as any).__action?.name || (t as any).name\n    ),\n    candidates: md.candidates,\n  });\n}\n"],"mappings":"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","names":["_a"]}