import {
  __spreadProps,
  __spreadValues
} from "./chunk-7OAPEGJQ.mjs";
import { GENKIT_VERSION } from "@genkit-ai/core";
import { logger } from "@genkit-ai/core/logging";
import {
  internalMetricNamespaceWrap,
  MetricCounter,
  MetricHistogram
} from "@genkit-ai/core/metrics";
import {
  spanMetadataAls,
  toDisplayPath,
  traceMetadataAls
} from "@genkit-ai/core/tracing";
import { ValueType } from "@opentelemetry/api";
import { createHash } from "crypto";
const MAX_LOG_CONTENT_CHARS = 128e3;
const _N = internalMetricNamespaceWrap.bind(null, "ai");
const generateActionCounter = new MetricCounter(_N("generate/requests"), {
  description: "Counts calls to genkit generate actions.",
  valueType: ValueType.INT
});
const generateActionLatencies = new MetricHistogram(_N("generate/latency"), {
  description: "Latencies when interacting with a Genkit model.",
  valueType: ValueType.DOUBLE,
  unit: "ms"
});
const generateActionInputCharacters = new MetricCounter(
  _N("generate/input/characters"),
  {
    description: "Counts input characters to any Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionInputTokens = new MetricCounter(
  _N("generate/input/tokens"),
  {
    description: "Counts input tokens to a Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionInputImages = new MetricCounter(
  _N("generate/input/images"),
  {
    description: "Counts input images to a Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionInputVideos = new MetricCounter(
  _N("generate/input/videos"),
  {
    description: "Counts input videos to a Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionInputAudio = new MetricCounter(_N("generate/input/audio"), {
  description: "Counts input audio files to a Genkit model.",
  valueType: ValueType.INT
});
const generateActionOutputCharacters = new MetricCounter(
  _N("generate/output/characters"),
  {
    description: "Counts output characters from a Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionOutputTokens = new MetricCounter(
  _N("generate/output/tokens"),
  {
    description: "Counts output tokens from a Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionOutputImages = new MetricCounter(
  _N("generate/output/images"),
  {
    description: "Count output images from a Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionOutputVideos = new MetricCounter(
  _N("generate/output/videos"),
  {
    description: "Count output videos from a Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionOutputAudio = new MetricCounter(
  _N("generate/output/audio"),
  {
    description: "Count output audio files from a Genkit model.",
    valueType: ValueType.INT
  }
);
function recordGenerateActionMetrics(modelName, input, opts) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  doRecordGenerateActionMetrics(modelName, ((_a = opts.response) == null ? void 0 : _a.usage) || {}, {
    temperature: (_b = input.config) == null ? void 0 : _b.temperature,
    topK: (_c = input.config) == null ? void 0 : _c.topK,
    topP: (_d = input.config) == null ? void 0 : _d.topP,
    maxOutputTokens: (_e = input.config) == null ? void 0 : _e.maxOutputTokens,
    flowName: (_g = (_f = traceMetadataAls) == null ? void 0 : _f.getStore()) == null ? void 0 : _g.flowName,
    path: (_i = (_h = spanMetadataAls) == null ? void 0 : _h.getStore()) == null ? void 0 : _i.path,
    latencyMs: (_j = opts.response) == null ? void 0 : _j.latencyMs,
    err: opts.err,
    source: "ts",
    sourceVersion: GENKIT_VERSION
  });
}
function recordGenerateActionInputLogs(model, input) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const flowName = (_b = (_a = traceMetadataAls) == null ? void 0 : _a.getStore()) == null ? void 0 : _b.flowName;
  const qualifiedPath = ((_d = (_c = spanMetadataAls) == null ? void 0 : _c.getStore()) == null ? void 0 : _d.path) || "";
  const path = toDisplayPath(qualifiedPath);
  const sharedMetadata = { model, path, qualifiedPath, flowName };
  logger.logStructured(`Config[${path}, ${model}]`, __spreadProps(__spreadValues({}, sharedMetadata), {
    temperature: (_e = input.config) == null ? void 0 : _e.temperature,
    topK: (_f = input.config) == null ? void 0 : _f.topK,
    topP: (_g = input.config) == null ? void 0 : _g.topP,
    maxOutputTokens: (_h = input.config) == null ? void 0 : _h.maxOutputTokens,
    stopSequences: (_i = input.config) == null ? void 0 : _i.stopSequences,
    source: "ts",
    sourceVersion: GENKIT_VERSION
  }));
  const messages = input.messages.length;
  input.messages.forEach((msg, msgIdx) => {
    const parts = msg.content.length;
    msg.content.forEach((part, partIdx) => {
      const partCounts = toPartCounts(partIdx, parts, msgIdx, messages);
      logger.logStructured(`Input[${path}, ${model}] ${partCounts}`, __spreadProps(__spreadValues({}, sharedMetadata), {
        content: toPartLogContent(part),
        partIndex: partIdx,
        totalParts: parts,
        messageIndex: msgIdx,
        totalMessages: messages
      }));
    });
  });
}
function recordGenerateActionOutputLogs(model, output) {
  var _a, _b, _c, _d;
  const flowName = (_b = (_a = traceMetadataAls) == null ? void 0 : _a.getStore()) == null ? void 0 : _b.flowName;
  const qualifiedPath = ((_d = (_c = spanMetadataAls) == null ? void 0 : _c.getStore()) == null ? void 0 : _d.path) || "";
  const path = toDisplayPath(qualifiedPath);
  const sharedMetadata = { model, path, qualifiedPath, flowName };
  const candidates = output.candidates.length;
  output.candidates.forEach((cand, candIdx) => {
    const parts = cand.message.content.length;
    cand.message.content.forEach((part, partIdx) => {
      const partCounts = toPartCounts(partIdx, parts, candIdx, candidates);
      const initial = cand.finishMessage ? { finishMessage: toPartLogText(cand.finishMessage) } : {};
      logger.logStructured(`Output[${path}, ${model}] ${partCounts}`, __spreadProps(__spreadValues(__spreadValues({}, initial), sharedMetadata), {
        content: toPartLogContent(part),
        partIndex: partIdx,
        totalParts: parts,
        candidateIndex: candIdx,
        totalCandidates: candidates,
        messageIndex: cand.index,
        finishReason: cand.finishReason
      }));
    });
  });
}
function toPartCounts(partOrdinal, parts, msgOrdinal, messages) {
  if (parts > 1 && messages > 1) {
    return `(part ${xOfY(partOrdinal, parts)} in message ${xOfY(
      msgOrdinal,
      messages
    )})`;
  }
  if (parts > 1) {
    return `(part ${xOfY(partOrdinal, parts)})`;
  }
  if (messages > 1) {
    return `(message ${xOfY(msgOrdinal, messages)})`;
  }
  return "";
}
function xOfY(x, y) {
  return `${x} of ${y}`;
}
function toPartLogContent(part) {
  if (part.text) {
    return toPartLogText(part.text);
  }
  if (part.media) {
    return toPartLogMedia(part);
  }
  if (part.toolRequest) {
    return toPartLogToolRequest(part);
  }
  if (part.toolResponse) {
    return toPartLogToolResponse(part);
  }
  return "<unknown format>";
}
function toPartLogText(text) {
  return text.substring(0, MAX_LOG_CONTENT_CHARS);
}
function toPartLogMedia(part) {
  if (part.media.url.startsWith("data:")) {
    const splitIdx = part.media.url.indexOf("base64,");
    if (splitIdx < 0) {
      return "<unknown media format>";
    }
    const prefix = part.media.url.substring(0, splitIdx + 7);
    const hashedContent = createHash("sha256").update(part.media.url.substring(splitIdx + 7)).digest("hex");
    return `${prefix}<sha256(${hashedContent})>`;
  }
  return toPartLogText(part.media.url);
}
function toPartLogToolRequest(part) {
  const inputText = typeof part.toolRequest.input === "string" ? part.toolRequest.input : JSON.stringify(part.toolRequest.input);
  return toPartLogText(
    `Tool request: ${part.toolRequest.name}, ref: ${part.toolRequest.ref}, input: ${inputText}`
  );
}
function toPartLogToolResponse(part) {
  const outputText = typeof part.toolResponse.output === "string" ? part.toolResponse.output : JSON.stringify(part.toolResponse.output);
  return toPartLogText(
    `Tool response: ${part.toolResponse.name}, ref: ${part.toolResponse.ref}, output: ${outputText}`
  );
}
function doRecordGenerateActionMetrics(modelName, usage, dimensions) {
  var _a;
  const shared = {
    modelName,
    flowName: dimensions.flowName,
    path: dimensions.path,
    temperature: dimensions.temperature,
    topK: dimensions.topK,
    topP: dimensions.topP,
    source: dimensions.source,
    sourceVersion: dimensions.sourceVersion,
    status: dimensions.err ? "failure" : "success"
  };
  generateActionCounter.add(1, __spreadValues({
    maxOutputTokens: dimensions.maxOutputTokens,
    error: (_a = dimensions.err) == null ? void 0 : _a.name
  }, shared));
  generateActionLatencies.record(dimensions.latencyMs, shared);
  generateActionInputTokens.add(usage.inputTokens, shared);
  generateActionInputCharacters.add(usage.inputCharacters, shared);
  generateActionInputImages.add(usage.inputImages, shared);
  generateActionInputVideos.add(usage.inputVideos, shared);
  generateActionInputAudio.add(usage.inputAudioFiles, shared);
  generateActionOutputTokens.add(usage.outputTokens, shared);
  generateActionOutputCharacters.add(usage.outputCharacters, shared);
  generateActionOutputImages.add(usage.outputImages, shared);
  generateActionOutputVideos.add(usage.outputVideos, shared);
  generateActionOutputAudio.add(usage.outputAudioFiles, shared);
}
export {
  recordGenerateActionInputLogs,
  recordGenerateActionMetrics,
  recordGenerateActionOutputLogs
};
//# sourceMappingURL=telemetry.mjs.map