"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var telemetry_exports = {};
__export(telemetry_exports, {
  recordGenerateActionInputLogs: () => recordGenerateActionInputLogs,
  recordGenerateActionMetrics: () => recordGenerateActionMetrics,
  recordGenerateActionOutputLogs: () => recordGenerateActionOutputLogs
});
module.exports = __toCommonJS(telemetry_exports);
var import_core = require("@genkit-ai/core");
var import_logging = require("@genkit-ai/core/logging");
var import_metrics = require("@genkit-ai/core/metrics");
var import_tracing = require("@genkit-ai/core/tracing");
var import_api = require("@opentelemetry/api");
var import_crypto = require("crypto");
const MAX_LOG_CONTENT_CHARS = 128e3;
const _N = import_metrics.internalMetricNamespaceWrap.bind(null, "ai");
const generateActionCounter = new import_metrics.MetricCounter(_N("generate/requests"), {
  description: "Counts calls to genkit generate actions.",
  valueType: import_api.ValueType.INT
});
const generateActionLatencies = new import_metrics.MetricHistogram(_N("generate/latency"), {
  description: "Latencies when interacting with a Genkit model.",
  valueType: import_api.ValueType.DOUBLE,
  unit: "ms"
});
const generateActionInputCharacters = new import_metrics.MetricCounter(
  _N("generate/input/characters"),
  {
    description: "Counts input characters to any Genkit model.",
    valueType: import_api.ValueType.INT
  }
);
const generateActionInputTokens = new import_metrics.MetricCounter(
  _N("generate/input/tokens"),
  {
    description: "Counts input tokens to a Genkit model.",
    valueType: import_api.ValueType.INT
  }
);
const generateActionInputImages = new import_metrics.MetricCounter(
  _N("generate/input/images"),
  {
    description: "Counts input images to a Genkit model.",
    valueType: import_api.ValueType.INT
  }
);
const generateActionInputVideos = new import_metrics.MetricCounter(
  _N("generate/input/videos"),
  {
    description: "Counts input videos to a Genkit model.",
    valueType: import_api.ValueType.INT
  }
);
const generateActionInputAudio = new import_metrics.MetricCounter(_N("generate/input/audio"), {
  description: "Counts input audio files to a Genkit model.",
  valueType: import_api.ValueType.INT
});
const generateActionOutputCharacters = new import_metrics.MetricCounter(
  _N("generate/output/characters"),
  {
    description: "Counts output characters from a Genkit model.",
    valueType: import_api.ValueType.INT
  }
);
const generateActionOutputTokens = new import_metrics.MetricCounter(
  _N("generate/output/tokens"),
  {
    description: "Counts output tokens from a Genkit model.",
    valueType: import_api.ValueType.INT
  }
);
const generateActionOutputImages = new import_metrics.MetricCounter(
  _N("generate/output/images"),
  {
    description: "Count output images from a Genkit model.",
    valueType: import_api.ValueType.INT
  }
);
const generateActionOutputVideos = new import_metrics.MetricCounter(
  _N("generate/output/videos"),
  {
    description: "Count output videos from a Genkit model.",
    valueType: import_api.ValueType.INT
  }
);
const generateActionOutputAudio = new import_metrics.MetricCounter(
  _N("generate/output/audio"),
  {
    description: "Count output audio files from a Genkit model.",
    valueType: import_api.ValueType.INT
  }
);
function recordGenerateActionMetrics(modelName, input, opts) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  doRecordGenerateActionMetrics(modelName, ((_a = opts.response) == null ? void 0 : _a.usage) || {}, {
    temperature: (_b = input.config) == null ? void 0 : _b.temperature,
    topK: (_c = input.config) == null ? void 0 : _c.topK,
    topP: (_d = input.config) == null ? void 0 : _d.topP,
    maxOutputTokens: (_e = input.config) == null ? void 0 : _e.maxOutputTokens,
    flowName: (_g = (_f = import_tracing.traceMetadataAls) == null ? void 0 : _f.getStore()) == null ? void 0 : _g.flowName,
    path: (_i = (_h = import_tracing.spanMetadataAls) == null ? void 0 : _h.getStore()) == null ? void 0 : _i.path,
    latencyMs: (_j = opts.response) == null ? void 0 : _j.latencyMs,
    err: opts.err,
    source: "ts",
    sourceVersion: import_core.GENKIT_VERSION
  });
}
function recordGenerateActionInputLogs(model, input) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const flowName = (_b = (_a = import_tracing.traceMetadataAls) == null ? void 0 : _a.getStore()) == null ? void 0 : _b.flowName;
  const qualifiedPath = ((_d = (_c = import_tracing.spanMetadataAls) == null ? void 0 : _c.getStore()) == null ? void 0 : _d.path) || "";
  const path = (0, import_tracing.toDisplayPath)(qualifiedPath);
  const sharedMetadata = { model, path, qualifiedPath, flowName };
  import_logging.logger.logStructured(`Config[${path}, ${model}]`, __spreadProps(__spreadValues({}, sharedMetadata), {
    temperature: (_e = input.config) == null ? void 0 : _e.temperature,
    topK: (_f = input.config) == null ? void 0 : _f.topK,
    topP: (_g = input.config) == null ? void 0 : _g.topP,
    maxOutputTokens: (_h = input.config) == null ? void 0 : _h.maxOutputTokens,
    stopSequences: (_i = input.config) == null ? void 0 : _i.stopSequences,
    source: "ts",
    sourceVersion: import_core.GENKIT_VERSION
  }));
  const messages = input.messages.length;
  input.messages.forEach((msg, msgIdx) => {
    const parts = msg.content.length;
    msg.content.forEach((part, partIdx) => {
      const partCounts = toPartCounts(partIdx, parts, msgIdx, messages);
      import_logging.logger.logStructured(`Input[${path}, ${model}] ${partCounts}`, __spreadProps(__spreadValues({}, sharedMetadata), {
        content: toPartLogContent(part),
        partIndex: partIdx,
        totalParts: parts,
        messageIndex: msgIdx,
        totalMessages: messages
      }));
    });
  });
}
function recordGenerateActionOutputLogs(model, output) {
  var _a, _b, _c, _d;
  const flowName = (_b = (_a = import_tracing.traceMetadataAls) == null ? void 0 : _a.getStore()) == null ? void 0 : _b.flowName;
  const qualifiedPath = ((_d = (_c = import_tracing.spanMetadataAls) == null ? void 0 : _c.getStore()) == null ? void 0 : _d.path) || "";
  const path = (0, import_tracing.toDisplayPath)(qualifiedPath);
  const sharedMetadata = { model, path, qualifiedPath, flowName };
  const candidates = output.candidates.length;
  output.candidates.forEach((cand, candIdx) => {
    const parts = cand.message.content.length;
    cand.message.content.forEach((part, partIdx) => {
      const partCounts = toPartCounts(partIdx, parts, candIdx, candidates);
      const initial = cand.finishMessage ? { finishMessage: toPartLogText(cand.finishMessage) } : {};
      import_logging.logger.logStructured(`Output[${path}, ${model}] ${partCounts}`, __spreadProps(__spreadValues(__spreadValues({}, initial), sharedMetadata), {
        content: toPartLogContent(part),
        partIndex: partIdx,
        totalParts: parts,
        candidateIndex: candIdx,
        totalCandidates: candidates,
        messageIndex: cand.index,
        finishReason: cand.finishReason
      }));
    });
  });
}
function toPartCounts(partOrdinal, parts, msgOrdinal, messages) {
  if (parts > 1 && messages > 1) {
    return `(part ${xOfY(partOrdinal, parts)} in message ${xOfY(
      msgOrdinal,
      messages
    )})`;
  }
  if (parts > 1) {
    return `(part ${xOfY(partOrdinal, parts)})`;
  }
  if (messages > 1) {
    return `(message ${xOfY(msgOrdinal, messages)})`;
  }
  return "";
}
function xOfY(x, y) {
  return `${x} of ${y}`;
}
function toPartLogContent(part) {
  if (part.text) {
    return toPartLogText(part.text);
  }
  if (part.media) {
    return toPartLogMedia(part);
  }
  if (part.toolRequest) {
    return toPartLogToolRequest(part);
  }
  if (part.toolResponse) {
    return toPartLogToolResponse(part);
  }
  return "<unknown format>";
}
function toPartLogText(text) {
  return text.substring(0, MAX_LOG_CONTENT_CHARS);
}
function toPartLogMedia(part) {
  if (part.media.url.startsWith("data:")) {
    const splitIdx = part.media.url.indexOf("base64,");
    if (splitIdx < 0) {
      return "<unknown media format>";
    }
    const prefix = part.media.url.substring(0, splitIdx + 7);
    const hashedContent = (0, import_crypto.createHash)("sha256").update(part.media.url.substring(splitIdx + 7)).digest("hex");
    return `${prefix}<sha256(${hashedContent})>`;
  }
  return toPartLogText(part.media.url);
}
function toPartLogToolRequest(part) {
  const inputText = typeof part.toolRequest.input === "string" ? part.toolRequest.input : JSON.stringify(part.toolRequest.input);
  return toPartLogText(
    `Tool request: ${part.toolRequest.name}, ref: ${part.toolRequest.ref}, input: ${inputText}`
  );
}
function toPartLogToolResponse(part) {
  const outputText = typeof part.toolResponse.output === "string" ? part.toolResponse.output : JSON.stringify(part.toolResponse.output);
  return toPartLogText(
    `Tool response: ${part.toolResponse.name}, ref: ${part.toolResponse.ref}, output: ${outputText}`
  );
}
function doRecordGenerateActionMetrics(modelName, usage, dimensions) {
  var _a;
  const shared = {
    modelName,
    flowName: dimensions.flowName,
    path: dimensions.path,
    temperature: dimensions.temperature,
    topK: dimensions.topK,
    topP: dimensions.topP,
    source: dimensions.source,
    sourceVersion: dimensions.sourceVersion,
    status: dimensions.err ? "failure" : "success"
  };
  generateActionCounter.add(1, __spreadValues({
    maxOutputTokens: dimensions.maxOutputTokens,
    error: (_a = dimensions.err) == null ? void 0 : _a.name
  }, shared));
  generateActionLatencies.record(dimensions.latencyMs, shared);
  generateActionInputTokens.add(usage.inputTokens, shared);
  generateActionInputCharacters.add(usage.inputCharacters, shared);
  generateActionInputImages.add(usage.inputImages, shared);
  generateActionInputVideos.add(usage.inputVideos, shared);
  generateActionInputAudio.add(usage.inputAudioFiles, shared);
  generateActionOutputTokens.add(usage.outputTokens, shared);
  generateActionOutputCharacters.add(usage.outputCharacters, shared);
  generateActionOutputImages.add(usage.outputImages, shared);
  generateActionOutputVideos.add(usage.outputVideos, shared);
  generateActionOutputAudio.add(usage.outputAudioFiles, shared);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  recordGenerateActionInputLogs,
  recordGenerateActionMetrics,
  recordGenerateActionOutputLogs
});
//# sourceMappingURL=telemetry.js.map